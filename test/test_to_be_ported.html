<script type="text/javascript">
    testSettingCagedPositionFromToken: function() { with(this) {
      var msg = "Caged position should follow position found in token";

      var chord = new jtabChord('C:1');
      var cagedPos = chord.cagedPos;
      assertNotUndefined( cagedPos );
      assertEqual( 1, cagedPos, msg );

      chord = new jtabChord('C:2');
      cagedPos = chord.cagedPos;
      assertEqual( 2, cagedPos, msg );

      chord = new jtabChord('C:3');
      cagedPos = chord.cagedPos;
      assertEqual( 3, cagedPos, msg );

      chord = new jtabChord('C:4');
      cagedPos = chord.cagedPos;
      assertEqual( 4, cagedPos, msg );
    }};

    testSettingCagedBaseFromToken: function() { with(this) {
      var msg = "Caged base fret position should derived from root note";

      var chord = new jtabChord('C');
      var cagedBaseShape = chord.cagedBaseShape;
      assertNotUndefined( cagedBaseShape );
      assertEqual( 'C', cagedBaseShape, msg );

      chord = new jtabChord('C#');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'C', cagedBaseShape, msg);

      chord = new jtabChord('D');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'D', cagedBaseShape, msg);

      chord = new jtabChord('D#');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'D', cagedBaseShape, msg);

      chord = new jtabChord('E');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'E', cagedBaseShape, msg);

      chord = new jtabChord('Eb');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'D', cagedBaseShape, msg);

      chord = new jtabChord('F');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'E', cagedBaseShape, msg);

      chord = new jtabChord('F#');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'E', cagedBaseShape, msg);

      chord = new jtabChord('G');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'G', cagedBaseShape, msg);

      chord = new jtabChord('G#');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'G', cagedBaseShape, msg);

      chord = new jtabChord('A');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'A', cagedBaseShape, msg);

      chord = new jtabChord('A#');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'A', cagedBaseShape, msg);

      chord = new jtabChord('Bb');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'A', cagedBaseShape, msg);

      chord = new jtabChord('B');
      cagedBaseShape = chord.cagedBaseShape;
      assertEqual( 'A', cagedBaseShape, msg);
    }};

    testChord_C_fingering: function() {  with(this) {
      var token = 'C';
      var modelChordArray = [ 0, [-1 ],  [3,3],  [2,2],  [0  ],  [1,1],  [0  ] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( ! c.isCaged, "jtabChord('" + token + "') should not be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testCustomChord_Bm7b5_fingering: function() {  with(this) {
      var token = "%7/2.X/X.7/3.7/4.6/1.X/X[Bm7b5]";

      var modelChordArray = [ 5, [7,2],  [-1 ],  [7,3],  [7,4],  [6,1],  [-1  ]]
      var c = new jtabChord(token);

			assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCustom, "jtabChord('" + token + "') should be custom chord" );
			assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};


    testCustomChord_F_fingering: function() {  with(this) {
      var token = "%8/2.X/X.7/1.10/4.X/X.X/X[F]";

      var modelChordArray = [ 6, [8,2],  [-1 ],  [7,1],  [10,4],  [-1 ],  [-1  ]]
      var c = new jtabChord(token);

			assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCustom, "jtabChord('" + token + "') should be custom chord" );
			assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

		testCustomChord_No_Name: function() {  with(this) {
		  var token = "%0/0.2/2.3/2.1/1.0/0.0/0";

		  var modelChordArray = [ 0, [0,0],  [2,2],  [3,2],  [1,1],  [0,0],  [0,0]]
		  var c = new jtabChord(token);
			assert( c.isValid, "jtabChord('" + token + "') should be valid" );
		  assert( c.isCustom, "jtabChord('" + token + "') should be custom chord" );
			assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
		}};


		testCustomChord_E_fingering: function() {  with(this) {
		  var token = "%0/0.2/2.3/2.1/1.0/0.0/0[E]";

		  var modelChordArray = [ 0, [0,0],  [2,2],  [3,2],  [1,1],  [0,0],  [0,0]]
		  var c = new jtabChord(token);

			assert( c.isValid, "jtabChord('" + token + "') should be valid" );
		  assert( c.isCustom, "jtabChord('" + token + "') should be custom chord" );
			assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
		}};

    testChord_C1_fingering: function() { with(this) {
      var token = 'C:1';
      var modelChordArray = [ 0, [-1 ],  [3,3],  [2,2],  [0  ],  [1,1],  [0  ] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_C2_fingering: function() { with(this) {
      var token = 'C:2';
      var modelChordArray = [ 2, [-1,-1 ],  [3,1],  [5,2],  [5,3],  [5,4],  [3,1] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_Cm_fingering: function() {  with(this) {
      var token = 'Cm';
      var modelChordArray = [ 0, [-1 ],  [3,4],  [1,2],  [0  ],  [1,1],  [-1 ] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( ! c.isCaged, "jtabChord('" + token + "') should not be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_Cm1_fingering: function() { with(this) {
      var token = 'Cm:1';
      var modelChordArray = [ 0, [-1 ],  [3,4],  [1,2],  [0  ],  [1,1],  [-1 ] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_Cm2_fingering: function() { with(this) {
      var token = 'Cm:2';
      var modelChordArray = [ 2, [-1,-1 ],  [3,1],  [5,3],  [5,4],  [4,2],  [3,1] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_A_fingering: function() {  with(this) {
      var token = 'A';
      var modelChordArray = [ 0, [-1],  [0  ],  [2,2],  [2,1],  [2,3],  [0  ] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( ! c.isCaged, "jtabChord('" + token + "') should not be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_A1_fingering: function() { with(this) {
      var token = 'A:1';
      var modelChordArray = [ 0, [-1],  [0  ],  [2,2],  [2,1],  [2,3],  [0  ] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_A2_fingering: function() { with(this) {
      var token = 'A:2';
      var modelChordArray = [ 1, [5,3],  [4,2],  [2,1],  [2,1],  [2,1],  [5,4  ] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_A3_fingering: function() { with(this) {
      var token = 'A:3';
      var modelChordArray = [ 4, [5,1],  [7,3],  [7,4],  [6,2],  [5,1],  [5,1  ] ];

      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_Dm7b5_fingering: function() {  with(this) {
      var token = 'Dm7b5';
      var modelChordArray = [ 0, [-1 ],  [-1 ],  [0  ],  [1,1],  [1,1],  [1,1] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( ! c.isCaged, "jtabChord('" + token + "') should not be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_Dm7b5p2_fingering: function() {  with(this) {
      var token = 'Dm7b5:2';
      var modelChordArray = [ 1, [-1, null], [5,1 ],  [6,3],  [5,2],  [6,4],  [-1, null] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( c.isCaged, "jtabChord('" + token + "') should be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_AddChord_insert: function() {  with(this) {
      var token = 'ATest';
      var modelChordArrayNew = [ 0, [-1],  [0  ],  [2,3],  [2,2],  [2,1],  [0  ] ];
      var c = new jtabChord(token);
      assert( !c.isValid, "jtabChord('" + token + "') should not initially be valid" );
      jtab.AddChord(token, [modelChordArrayNew]);
      c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid after insert" );
      assertHashEqual( modelChordArrayNew, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }};

    testChord_AddChord_update: function() {  with(this) {
      var token = 'A';
      var modelChordArray = [ 0, [-1],  [0  ],  [2,2],  [2,1],  [2,3],  [0  ] ];
      var modelChordArrayNew = [ 0, [-1],  [0  ],  [2,2],  [2,2],  [2,3],  [0  ] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should initially be valid" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray before update" );
      jtab.AddChord(token, [modelChordArrayNew]);
      c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid after update" );
      assertHashEqual( modelChordArrayNew, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray after update" );
    }};

    testChord_Csharpm_fingering: function() {  with(this) {
      var token = 'C#m';
      var modelChordArray = [ 0, [-1 ],  [-1],  [2,2],  [1,1],  [2,3],  [0] ];
      var c = new jtabChord(token);
      assert( c.isValid, "jtabChord('" + token + "') should be valid" );
      assert( ! c.isCaged, "jtabChord('" + token + "') should not be CAGED" );
      assertHashEqual( modelChordArray, c.chordArray, "jtabChord('" + token + "') returned incorrect chordArray" );
    }}

  });
// ]]>
</script>
</body>
</html>